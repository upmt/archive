import{e as d,E as i,b as c,c as w,u as D,f as y,g as S,h as x,D as O,m as h,s as g,i as k,F as v,j,S as C,n as _,w as T,A as B,d as M,k as R,l as L}from"./index-CVx01Jnn.js";function b(e){return e!=null&&typeof e=="object"&&"create"in e&&typeof e.create=="function"}async function P(e,t){if(typeof t!="object"||t===null)throw d(new i(c.EINVAL,"Invalid options"));for(const[r,s]of Object.entries(e.options)){const n=t?.[r];if(n==null){if(!s.required){w("Missing non-required option: "+r);continue}throw d(new i(c.EINVAL,"Missing required option: "+r))}const o=(a,u=n)=>typeof a=="function"?n instanceof a:typeof n===a;if(Array.isArray(s.type)?!s.type.some(a=>o(a)):!o(s.type)){const a=typeof n=="object"&&"constructor"in n?n.constructor.name:typeof n,u=f=>typeof f=="function"?f.name:f,N=Array.isArray(s.type)?`one of ${s.type.map(u).join(", ")}`:u(s.type);throw d(new i(c.EINVAL,`Incorrect type for "${r}": ${a} (expected ${N})`))}w("Using custom validator for option: "+r),s.validator&&await s.validator(n)}}function I(e){return e!=null&&typeof e=="object"&&"backend"in e&&b(e.backend)}function p(e){return I(e)||b(e)||e instanceof v}async function A(e,t=0){if(typeof e!="object"||e==null)throw d(new i(c.EINVAL,"Invalid options on mount configuration"));if(!p(e))throw d(new i(c.EINVAL,"Invalid mount configuration"));if(e instanceof v)return await e.ready(),e;b(e)&&(e={backend:e});for(const[n,o]of Object.entries(e))if(n!="backend"&&p(o)){if(j("Resolving nested mount configuration: "+n),t>10)throw d(new i(c.EINVAL,"Invalid configuration, too deep and possibly infinite"));e[n]=await A(o,++t)}const{backend:r}=e;if(typeof r.isAvailable=="function"&&!await r.isAvailable())throw d(new i(c.EPERM,"Backend not available: "+r.name));await P(r,e);const s=await r.create(e);return e.disableAsyncCache&&s.attributes.set("no_async"),await s.ready(),s}async function m(e,t){if(e=="/"){h(e,t);return}const r=await g(e).catch(()=>null);if(!r)await k(e,{recursive:!0});else if(!r.isDirectory())throw i.With("ENOTDIR",e,"configure");h(e,t)}async function F(e){var t;const r="uid"in e&&e.uid||0,s="gid"in e&&e.gid||0;if(D({uid:r,gid:s}),y.checkAccess=!e.disableAccessChecks,y.updateOnRead=!e.disableUpdateOnRead,y.syncImmediately=!e.onlySyncOnClose,e.log&&S(e.log),e.mounts)for(const[n,o]of Object.entries(e.mounts).sort(([a],[u])=>a.length>u.length?1:-1)){const a=n.startsWith("/")?n:"/"+n;I(o)&&((t=o.disableAsyncCache)!==null&&t!==void 0||(o.disableAsyncCache=e.disableAsyncCache||!1)),a=="/"&&x("/"),await m(a,await A(o))}if(e.addDevices){const n=new O;n.addDefaults(),await n.ready(),await m("/dev",n)}}function V(e){switch(e.name){case"TypeMismatchError":return"EPERM";case"IndexSizeError":case"HierarchyRequestError":case"InvalidCharacterError":case"InvalidStateError":case"SyntaxError":case"NamespaceError":case"ConstraintError":case"VersionError":case"URLMismatchError":case"InvalidNodeTypeError":return"EINVAL";case"WrongDocumentError":return"EXDEV";case"NoModificationAllowedError":case"InvalidModificationError":case"InvalidAccessError":case"SecurityError":case"NotAllowedError":return"EACCES";case"NotFoundError":return"ENOENT";case"NotSupportedError":return"ENOTSUP";case"InUseAttributeError":return"EBUSY";case"NetworkError":return"ENETDOWN";case"AbortError":return"EINTR";case"QuotaExceededError":return"ENOSPC";case"TimeoutError":return"ETIMEDOUT";case"ReadOnlyError":return"EROFS";case"DataCloneError":case"EncodingError":case"NotReadableError":case"DataError":case"TransactionInactiveError":case"OperationError":case"UnknownError":default:return"EIO"}}function E(e,t,r){if(e instanceof i)return e;const s=e instanceof DOMException?c[V(e)]:c.EIO,n=new i(s,e.message,t,r);return n.stack=e.stack,n.cause=e.cause,n}function l(e){return new Promise((t,r)=>{e.onsuccess=()=>t(e.result),e.onerror=s=>{s.preventDefault(),r(E(e.error))}})}class z extends B{constructor(t,r){super(r),this.tx=t,this.store=r,this._idb=t.objectStore(r.name)}async keys(){return(await l(this._idb.getAllKeys())).filter(t=>typeof t=="string").map(t=>Number(t))}async get(t){const r=await l(this._idb.get(t.toString()));return r&&this._cached(t,{size:r.byteLength}).add(r,0),r}async set(t,r){this._cached(t,{size:r.byteLength}).add(r,0),await l(this._idb.put(r,t.toString()))}remove(t){return this.store.cache.delete(t),l(this._idb.delete(t.toString()))}async commit(){const{promise:t,resolve:r,reject:s}=Promise.withResolvers();return this.tx.oncomplete=()=>r(),this.tx.onerror=()=>s(E(this.tx.error)),this.tx.commit(),t}async abort(){const{promise:t,resolve:r,reject:s}=Promise.withResolvers();return this.tx.onabort=()=>r(),this.tx.onerror=()=>s(E(this.tx.error)),this.tx.abort(),t}}async function U(e,t=globalThis.indexedDB){const r=t.open(e);return r.onupgradeneeded=()=>{const s=r.result;s.objectStoreNames.contains(e)&&(T("Found unexpected object store: "+e),s.deleteObjectStore(e)),s.createObjectStore(e)},await l(r)}class ${constructor(t){this.db=t,this.cache=new Map}sync(){return Promise.resolve()}get name(){return this.db.name}transaction(){const t=this.db.transaction(this.name,"readwrite");return new z(t,this)}}const q={name:"IndexedDB",options:{storeName:{type:"string",required:!1},idbFactory:{type:"object",required:!1}},async isAvailable(e=globalThis.indexedDB){try{if(!(e instanceof IDBFactory))return!1;const t=e.open("__zenfs_test");return await l(t),!0}catch{return!1}finally{e.deleteDatabase("__zenfs_test")}},async create(e){const t=await U(e.storeName||"zenfs",e.idbFactory),r=new $(t),s=new C(r);if(e?.disableAsyncCache)return _("Async preloading disabled for IndexedDB"),s;const n=r.transaction();for(const o of await n.keys())await n.get(o);return s}},W=q,K=M(async()=>{await F({mounts:{"/":W}}),console.log("zenfs boot configured",R),window.fs=L,navigator.storage&&navigator.storage.persist&&(await navigator.storage.persisted()||navigator.storage.persist())});export{K as default,L as fs};
